from math import ceil
import pickle

from silospin.math.math_helpers import *
from silospin.experiment.setup_experiment_helpers import unpickle_qubit_parameters

import zhinst
from zhinst.toolkit import Session
import inspect
from zhinst.toolkit import CommandTable

def channel_mapper(rf_dc_awg_grouping = {"hdawg1": {"rf":  [1,2,3,4], "dc": []}, "hdawg2":  {"rf": [1], "dc": [2,3,4]}}, trig_channels = {"hdawg1": 1, "hdawg2": 1}):
    '''
    Outputs a dictionary representing the mapping between AWG cores and gate identifiers used by the quantum compiler. \n


    Parameters:
                    rf_dc_awg_grouping (dict): dictionary RF/DC core split. outer key corresponds to HDAWG unit (e.g. "awg1") with values as dictionaries of grouping between RF and DC cores. \n
                    [default set to {"awg1": {"rf":  [1,2,3,4], "dc": []}, "awg2":  {"rf": [1], "dc": [2,3,4]}}\n

    Returns:
       channel_mapper (dict): channel mapping for each core,. each with channel labels "core_idx", "channel_labels", "gate_idx".
    '''
    channel_mapping = {}
    hdawg_mapping = {}
    core_count = 0
    ch_1_idx = -1
    ch_2_idx = 0
    for awg_idx in rf_dc_awg_grouping:
        ch_core_1_idx = -1
        ch_core_2_idx = 0
        channel_mapping[awg_idx] = {1: {}, 2: {}, 3: {}, 4:{}}
        rf_cores = set(rf_dc_awg_grouping[awg_idx]["rf"])
        dc_cores = set(rf_dc_awg_grouping[awg_idx]["dc"])
        for core_idx in channel_mapping[awg_idx]:
            core_count+=1
            ch_1_idx+=2
            ch_2_idx+=2
            ch_core_1_idx += 2
            ch_core_2_idx += 2

            if trig_channels[awg_idx] == ch_core_1_idx:
                trig_in = [1,0]
            elif trig_channels[awg_idx] == ch_core_2_idx:
                trig_in = [0,1]
            else:
                trig_in = [0,0]

            if core_idx in rf_cores:
                rf_dc_awg_grouping[awg_idx]["rf"].append(core_count)
                channel_mapping[awg_idx][core_idx] = {"core_idx": core_count, "channel_core_number":[ch_core_1_idx, ch_core_2_idx], "channel_number":[ch_1_idx, ch_2_idx], "trig_channel": trig_in, "channel_labels":["i"+str(core_count), "q"+str(core_count)],"gate_idx":[core_count,core_count], "rf": 1}
                hdawg_mapping[core_count] = (awg_idx, core_idx)
            elif core_idx in dc_cores:
                rf_dc_awg_grouping[awg_idx]["dc"].append(ch_1_idx)
                rf_dc_awg_grouping[awg_idx]["dc"].append(ch_2_idx)
                channel_mapping[awg_idx][core_idx] = {"core_idx": core_count, "channel_core_number":[ch_core_1_idx, ch_core_2_idx], "channel_number":[ch_1_idx, ch_2_idx], "trig_channel": trig_in, "channel_labels":["p"+str(ch_1_idx), "p"+str(ch_2_idx)],"gate_idx":[ch_1_idx,ch_2_idx], "rf": 0}
                hdawg_mapping[ch_1_idx] = (awg_idx, core_idx)
                hdawg_mapping[ch_2_idx] = (awg_idx, core_idx)
            else:
                pass
    return channel_mapping, hdawg_mapping

def make_gate_parameters(tau_pi, tau_pi_2, i_amp, q_amp, mod_freq, plunger_length, plunger_amp):
    gate_parameters = {}
    gate_parameters["rf"] = {}
    gate_parameters["p"] = {}

    for rf_idx in tau_pi:
        gate_parameters["rf"][rf_idx] = {"i_amp": None, "q_amp": None, "tau_pi" : None,  "tau_pi_2" :  None,  "mod_freq": None}
        gate_parameters["rf"][rf_idx]["i_amp"] = i_amp[rf_idx]
        gate_parameters["rf"][rf_idx]["q_amp"] = q_amp[rf_idx]
        gate_parameters["rf"][rf_idx]["tau_pi"] = tau_pi[rf_idx]
        gate_parameters["rf"][rf_idx]["tau_pi_2"] = tau_pi_2[rf_idx]
        gate_parameters["rf"][rf_idx]["mod_freq"] = mod_freq[rf_idx]
    for p_idx in plunger_length:
        gate_parameters["p"][p_idx] = {"tau": None, "p_amp": None}
        gate_parameters["p"][p_idx]["tau"] = plunger_length[p_idx]
        gate_parameters["p"][p_idx]["p_amp"] = plunger_amp[p_idx]
    return gate_parameters

def make_gate_lengths(dc_times, t_pi_2_max, t_pi_max, channel_map):
    '''
    Outputs a dictionary with the standard pi, pi/2, and DC pulse lengths in seconds for each gate.

    Parameters:
                    dc_times (dict): dictionary of DC pulse durations for all specified channels, in ns.
                    gate_parameters (dict): dictionary of gate parameters generated by the 'make_gate_parameters' function.
                    t_pi_2_max (float): max pi/2 pulse duration among all qubits, in ns.
                    t_pi_max (float): max pi pulse duration among all qubits, in ns.
    Returns:
       gate_lengths (dict): dictonary of DC an RF gate lengths in ns. Outer dictionary keys are 'rf' and 'plunger'.
    '''
    gate_lengths = {"rf": {}, "plunger": {}}
    for awg in channel_map:
        for core in channel_map[awg]:
            if channel_map[awg][core]['rf'] == 1:
                ch_rf_idx = channel_map[awg][core]['gate_idx'][0]
                gate_lengths["rf"][ch_rf_idx] = {"pi": t_pi_max, "pi_2": t_pi_2_max}
            elif channel_map[awg][core]['rf'] == 0:
                ch_idx_1 = channel_map[awg][core]['gate_idx'][0]
                ch_idx_2 = channel_map[awg][core]['gate_idx'][1]
                t_p_1 = ceil(dc_times[ch_idx_1])
                t_p_2 = ceil(dc_times[ch_idx_2])
                gate_lengths["plunger"][ch_idx_1] = {"p": t_p_1}
                gate_lengths["plunger"][ch_idx_2] = {"p": t_p_2}
            else:
                pass
    return gate_lengths

def make_command_table_indices(gt_seqs, channel_map, awg_core_split, arb_gates, plunger_tup_lengths, taus_std, gate_lengths, arbgate_counter, arbZs, line, arb_dc_dict, pickle_file_location='C:\\Users\\Sigillito Lab\\Desktop\\experimental_workspaces\\quantum_dot_workspace_bluefors1\\experiment_parameters\\bluefors1_arb_gates.pickle'):
    '''
    Generates a dictionary with lists of command table executions for each core, provided the output of 'gst_file_parser'.
    This is the core of the quantum compiler, as it interprets longs RF and DC gate strings, converting them to FPGA instructions for amplitude and phase modulation.\n
    Outer-most keys "plunger" and "rf", containing instructions to be addressed separatley on the dedicated RF and DC cores.
    Outputs a dictionary with outer keys "rf" and "plunger", corresponding to executions for dedicated RF and DC AWG cores. The values for the "rf" keys are dictionaries with outer keys corresponding to each core and "plunger"
    has values of dictionaries with keys corresponding to each DC channel. Each of these core and channel keys have values of lists of command table (CT) indices (integers) to be addressed on the AWG cores. \n
    Each command table index maps to an entry of a CT, determining the waveform, amplitude, and phase to be played when the CT entry is executed. Phase changes for each gate are computed on-the-fly.
    Note that this function supports the following gates:  'x', 'xxx', 'xx', 'mxxm', 'y', 'yyy', 'y y', 'myym', 'arbZ', 'p', 't'. See 'Quantum Compiler' tab for a more elaborate description.  \n
    Note: this function is currently configured for 1 HDAWG unit with 4 AWG cores. \n

    Parameters:
                    gt_seqs (dict): dictionary output of 'gst_file_parser', representing sequence of RF and DC gate strings on each core.
                    taus_std (list): list of standard pi/2 and pi pulse lengths in ns ([tau_pi2, tau_pi]).
                    taus_p (list): list of tuples, each with elements (ch_idx, tau_p) representing the channel index and corresponding plunger pulse length.
                    n_arbZ (int): the accumulated number of previously seen arbitrary-Z rotations over all lines in GST file being read.

    Returns:
       ct_idxs (dict), arbZ (list): dictonary of command table indices to execute, list of tuples of (arbitrary Z comman table index, rotation angle).
     '''

    ct_idxs = {}
    for awg_idx in channel_map:
        ct_idxs[awg_idx] = {}
        for core_idx in channel_map[awg_idx]:
            ct_idxs[awg_idx][core_idx] = {}

    initial_gates = {'xx_pi_fr': 0, 'yy_pi_fr': 1, 'mxxm_pi_fr': 2, 'myym_pi_fr': 3, 'x_pi_fr': 4, 'y_pi_fr': 5, 'xxx_pi_fr': 6, 'yyy_pi_fr': 7, 'x_pi2_fr': 8, 'y_pi2_fr': 9, 'xxx_pi2_fr': 10, 'yyy_pi2_fr': 11, 'xx_p_fr': 12, 'yy_p_fr': 13, 'mxxm_p_fr': 14, 'myym_p_fr': 15, 'x_p_fr': 16, 'y_p_fr': 17, 'xxx_p_fr': 18, 'yyy_p_fr': 19}
    ct_idx_incr_pi_pi_fr = {0: 20, -90: 21, -180: 22, -270: 23, 90: 24, 180: 25, 270: 26, 360: 20, -360: 20}
    ct_idx_incr_pi_2_pi_fr = {0: 27, -90: 28, -180: 29, -270: 30, 90: 31, 180: 32,  270: 33, 360: 20, -360: 20}
    ct_idx_incr_pi_2_pi_2_fr = {0: 34, -90: 35, -180: 36, -270: 37, 90: 38, 180: 39,  270:  40, 360: 20, -360: 20}
    ct_idx_incr_pi_p_fr = {0: 41, -90: 42, -180: 43, -270: 44, 90: 45, 180: 46,  270:  47, 360: 20, -360: 20}
    ct_idx_incr_pi_2_p_fr = {0: 48, -90: 49, -180: 50, -270: 51, 90: 51, 180: 53,  270:  54, 360: 20, -360: 20}
    ct_idx_z0z = 55
    phi_ls_gt = {'x':  0, 'y': 90, 'xx':  0, 'yy': 90 , 'xxx':  180, 'yyy': -90, 'mxxm': 180, 'myym': -90}
    pi_gt_set = {'xx', 'yy', 'mxxm', 'myym'}
    pi_2_gt_set = {'x', 'y', 'xxx', 'yyy'}

    rf_gate_sequence = gt_seqs['rf']
    dc_gate_sequence = gt_seqs['plunger']


    arbgate_dict = unpickle_qubit_parameters(pickle_file_location)
    plunger_len_set = set([gate_lengths['plunger'][item]['p'] for item in gate_lengths['plunger']])
    plunger_len_tups = [(item, gate_lengths['plunger'][item]['p']) for item in gate_lengths['plunger']]

    N_p = len(plunger_tup_lengths)
    if len(plunger_len_tups) == 0:
        p_std_idx = 0     
    else:
        p_tup_std = max(plunger_len_tups, key=lambda x:x[1])
        p_std_idx = 0
        for item in plunger_len_tups:
            if p_tup_std[0] == item[0]:
                break
            else:
                p_std_idx += 1

    ct_idx_p1_pi = 3*N_p
    ct_idx_p2_pi = 3*N_p + 1
    ct_idx_p1_pi_2 = 3*N_p + 2
    ct_idx_p2_pi_2 = 3*N_p + 3
    ct_idx_p1_p2_pi = 3*N_p + 4
    ct_idx_p1_p2_pi_2 = 3*N_p + 6
    ct_idx_p_z0z = 3*N_p + 7
    ct_p_idx_tau_pi = 3*N_p + 7
    ct_p_idx_tau_pi_2 = 3*N_p + 8
    ct_p_idx_tau_p_std = 3*N_p + 9

    N_arb_tot = 0
    sample_rate = 2.4e9
    arb_gate_taus = []
    for i in arb_gates:
        for j in arb_gates[i]:
            for k in range(len(arb_gates[i][j])):
                N_arb_tot += 1
                arb_gate_taus.append(ceil(1e9*len(arb_gates[i][j][k][1])/sample_rate))

    for rf_idx in rf_gate_sequence:
        arb_gate_counter = 0
        awg_idx = awg_core_split[rf_idx][0]
        core_idx = awg_core_split[rf_idx][1]
        N_z = len(arbZs[awg_idx][core_idx])
        rf_diff_idxs = list(set([i for i in rf_gate_sequence.keys()]).difference({rf_idx}))
        gate_sequence = rf_gate_sequence[rf_idx]
        n_gates = len(gate_sequence)
        gt_0 = gate_sequence[0]
        ct_idx_tau_pi = 56 + len(arbZs[awg_idx][core_idx])
        ct_idx_tau_pi_2 = 57 + len(arbZs[awg_idx][core_idx])

        ##Compute initial phase
        if gt_0 in {'x', 'y', 'xxx', 'yyy', 'mxxm', 'myym', 'xx', 'yy'}:
            phi_l = phi_ls_gt[gt_0]
        elif gt_0.find('*') != -1:
              if gt_0[gt_0.find('*')+1] == 'X':
                   phi_l = phi_ls_gt['x']
              elif gt_0[gt_0.find('*')+1] == 'Y':
                   phi_l = phi_ls_gt['y']
              elif gt_0[gt_0.find('*')+1] == 'U':
                   phi_l = phi_ls_gt['xxx']
              elif gt_0[gt_0.find('*')+1] == 'V':
                   phi_l = phi_ls_gt['yyy']
              else:
                   pass
        else:
            phi_l = 0

        rf_gt_idx  = 0
        non_rf_idx = 0

        for idx in range(n_gates):
            gt = gate_sequence[idx]
            rf_gates_other = set([rf_gate_sequence[j][idx] for j in rf_diff_idxs])
            pi_2_intersect = rf_gates_other.intersection(pi_2_gt_set)
            pi_intersect = rf_gates_other.intersection(pi_gt_set)
            p_intersect = set([dc_gate_sequence[seq][idx] for seq in dc_gate_sequence]).intersection({'p'})
            p_intersect_tups = set([(seq, dc_gate_sequence[seq][idx]) for seq in dc_gate_sequence])

            if gt in {'x', 'y', 'mxxm', 'myym', 'xxx', 'yyy', 'xx', 'yy'}:
                rf_gt_idx += 1
            elif gt.find('*') != -1:
                if gt[gt.find('*')+1] in {'X', 'Y', 'U', 'V'}:
                    rf_gt_idx += 1
                else:
                    pass
            else:
                non_rf_idx += 1
            # initial pi gate
            if gt in pi_gt_set and rf_gt_idx == 1:
                if len(p_intersect) != 0:
                    for tup in p_intersect_tups:
                        if tup[1] == 'p':
                            tau_p = int(gate_lengths['plunger'][tup[0]]['p'])
                            #Plunger frame
                            if tau_p > taus_std[1]:
                                gt_str = gt+'_p_fr'
                                break
                            #Pi frame
                            else:
                                gt_str = gt+'_pi_fr'
                        else:
                            gt_str = gt+'_pi_fr'
                else:
                    gt_str = gt+'_pi_fr'
                ct_idxs[awg_idx][core_idx][idx] = initial_gates[gt_str]
           # initial pi/2 gate
            elif gt in pi_2_gt_set and rf_gt_idx == 1:
                if len(p_intersect) != 0:
                    for tup in p_intersect_tups:
                        if tup[1] == 'p':
                            #Obtain DC pulse length
                            tau_p = int(gate_lengths['plunger'][tup[0]]['p'])
                            #No pi pulses, just pi/2 and plunger ==> plunger > pi/2
                            if len(pi_intersect) == 0 and tau_p > taus_std[0]:
                                gt_str = gt+'_p_fr'
                                break
                            #Pi pulses, with pi/2 and plunger ==> plunger > pi
                            elif len(pi_intersect) != 0 and tau_p > taus_std[1]:
                                gt_str = gt+'_p_fr'
                                break
                           #Pi pulses, with pi/2 and plunger ==> plunger < pi
                            elif len(pi_intersect) != 0 and tau_p < taus_std[1]:
                                gt_str = gt+'_pi_fr'
                            elif len(pi_intersect) == 0 and tau_p < taus_std[0]:
                                gt_str = gt+'_pi2_fr'
                            else:
                                pass
                        else:
                            pass
                elif len(pi_intersect) != 0:
                    gt_str = gt+'_pi_fr'
                else:
                    gt_str = gt+'_pi2_fr'
                ct_idxs[awg_idx][core_idx][idx] = initial_gates[gt_str]

           # z0z gate
            elif gt == 'z0z':
                ct_idxs[awg_idx][core_idx][idx] = ct_idx_z0z

            # z gate
            elif gt[0] == 'z':
                ct_idxs[awg_idx][core_idx][idx] = arbZs[awg_idx][core_idx][gt][0]
            #  delays
            elif gt[0] == 't':
                gt_t_str = int(gt[1:len(gt)])
                if gt_t_str == int(taus_std[1]):
                    ct_idxs[awg_idx][core_idx][idx] = ct_idx_tau_pi
                # std pi/2 delays
                elif gt_t_str == int(taus_std[0]):
                    ct_idxs[awg_idx][core_idx][idx] = ct_idx_tau_pi_2
                # plunger delays
                else:
                    if gt_t_str in plunger_len_set:
                        idx_p = 0
                        for itm in plunger_len_tups:
                            idx_p += 1
                            if gt_t_str == itm[1]:
                                ct_idx_t_p  = 58 + idx_p + N_z
                                ct_idxs[awg_idx][core_idx][idx] = ct_idx_t_p
                                break
                            else:
                                continue
                    ##Arb gate delays  (need to test with arb gate)
                    elif gt_t_str in set(arb_gate_taus):
                        idx_a = 0
                        for itm in arb_gate_taus:
                            idx_a += 1
                            if gt_t_str == itm:
                                ct_idx_t_a  = 58 + idx_a + N_z + N_p
                                ct_idxs[awg_idx][core_idx][idx] = ct_idx_t_a
                                break
                            else:
                                continue
                    else:
                        pass
            ##Arbitrary gates
            elif gt.find('*') != -1:
                if gt[gt.find('*')+1] in arbgate_dict.keys():
                    if gt[gt.find('*')+1] in {'X', 'Y', 'U', 'V'}:
                        ##Initial gate
                        if rf_gt_idx == 1:
                            init_gate_map = {'X': 1, 'Y': 2, 'U': 3, 'V': 4}
                            ct_idx_g_a = 58 + N_z + N_p + N_arb_tot + init_gate_map[gt[gt.find('*')+1]]+arbgate_counter[awg_idx][core_idx]
                            arbgate_counter[awg_idx][core_idx] += 11
                        ##Incremented gate
                        elif rf_gt_idx > 1:
                           if gt[gt.find('*')+1] == 'X':
                               phi_l, phi_a = compute_accumulated_phase('X', phi_l)
                           elif gt[gt.find('*')+1] == 'Y':
                               phi_l, phi_a = compute_accumulated_phase('Y', phi_l)
                           elif gt[gt.find('*')+1] == 'U':
                               phi_l, phi_a = compute_accumulated_phase('U', phi_l)
                           elif gt[gt.find('*')+1] == 'V':
                               phi_l, phi_a = compute_accumulated_phase('V', phi_l)
                           else:
                               pass
                           incr_gate_map = {0: 5, -90 : 6, -180: 7, -270: 8, 90: 9, 180: 10, 270: 11, -360: 5, 360: 5}
                           ct_idx_g_a = 58 + N_z + N_p + N_arb_tot + incr_gate_map[phi_a]+arbgate_counter[awg_idx][core_idx]
                           arbgate_counter[awg_idx][core_idx] += 11
                        else:
                            pass
                    else:
                         ct_idx_g_a = 59 + N_z + N_p + N_arb_tot + arbgate_counter[awg_idx][core_idx]
                         arbgate_counter[awg_idx][core_idx] += 1
                else:
                    pass
                ct_idxs[awg_idx][core_idx][idx] = ct_idx_g_a

            ## Incremented RF gates (non-arbitrary)
            elif rf_gt_idx > 1:
                ##Compute phase
                if gt in {'x', 'y', 'xxx', 'yyy', 'xx', 'yy', 'mxxm', 'myym'}:
                    phi_l, phi_a = compute_accumulated_phase(gt, phi_l)
                else:
                    pass
                ##Incremented pi gate
                if gt in pi_gt_set:
                     if len(p_intersect) != 0:
                        for tup in p_intersect_tups:
                            if tup[1] == 'p':
                                tau_p = int(gate_lengths['plunger'][tup[0]]['p'])
                                #Plunger frame
                                if tau_p > taus_std[1]:
                                    ct_idx_incr = ct_idx_incr_pi_p_fr[phi_a]
                                    break
                                #Pi frame
                                else:
                                    ct_idx_incr = ct_idx_incr_pi_pi_fr[phi_a]
                            else:
                                ct_idx_incr = ct_idx_incr_pi_pi_fr[phi_a]
                     else:
                         ct_idx_incr = ct_idx_incr_pi_pi_fr[phi_a]
                     ct_idxs[awg_idx][core_idx][idx] = ct_idx_incr
                ##Incremented pi/2 gate
                elif gt in pi_2_gt_set:
                    if len(p_intersect) != 0:
                        for tup in p_intersect_tups:
                            if tup[1] == 'p':
                                #Obtain DC pulse length
                                tau_p = int(gate_lengths['plunger'][tup[0]]['p'])
                                #No pi pulses, just pi/2 and plunger ==> plunger > pi/2
                                if len(pi_intersect) == 0 and tau_p > taus_std[0]:
                                    ct_idx_incr = ct_idx_incr_pi_2_p_fr[phi_a]
                                    break
                                #Pi pulses, with pi/2 and plunger ==> plunger > pi
                                elif len(pi_intersect) != 0 and tau_p > taus_std[1]:
                                    ct_idx_incr = ct_idx_incr_pi_2_p_fr[phi_a]
                                    break
                               #Pi pulses, with pi/2 and plunger ==> plunger < pi
                                elif len(pi_intersect) != 0 and tau_p < taus_std[1]:
                                    ct_idx_incr = ct_idx_incr_pi_2_pi_fr[phi_a]
                                elif len(pi_intersect) == 0 and tau_p < taus_std[0]:
                                    ct_idx_incr = ct_idx_incr_pi_2_pi_2_fr[phi_a]
                                else:
                                    pass
                            else:
                                pass
                    elif len(pi_intersect) != 0:
                        ct_idx_incr = ct_idx_incr_pi_2_pi_fr[phi_a]
                    else:
                        ct_idx_incr = ct_idx_incr_pi_2_pi_2_fr[phi_a]
                    ct_idxs[awg_idx][core_idx][idx] = ct_idx_incr
            ## Consider throwing error here
                else:
                    pass

    ##Start here
    if len(dc_gate_sequence.keys()) == 0:
        pass
    else:

        idx_temp = list(dc_gate_sequence.keys())[0]
        n_gates = len(dc_gate_sequence[idx_temp])

        check_dc_p_channels = {}
        for i in range(n_gates):
            check_dc_p_channels[i] = {}
            for dc_idx in dc_gate_sequence:
                check_dc_p_channels[i][dc_idx] = 0

        for dc_idx in dc_gate_sequence:
            arb_gate_counter = 0
            awg_idx = awg_core_split[dc_idx][0]
            core_idx = awg_core_split[dc_idx][1]
            dc_diff_idxs = list(set([i for i in dc_gate_sequence.keys()]).difference({dc_idx}))
            rf_diff_idxs = list(set([i for i in rf_gate_sequence.keys()]))
            gate_sequence = dc_gate_sequence[dc_idx]
            n_gates = len(gate_sequence)

            ##Loop through all gates
            for idx in range(n_gates):
                gt = gate_sequence[idx]
                dc_gates_other = set([dc_gate_sequence[j][idx] for j in dc_diff_idxs])
                p_gates_other = dc_gates_other.intersection({'p'})
                rf_gates_other = set([rf_gate_sequence[j][idx] for j in rf_diff_idxs])
                pi_2_intersect = rf_gates_other.intersection(pi_2_gt_set)
                pi_intersect = rf_gates_other.intersection(pi_gt_set)

                if gt == 'p':
                    itr = 0
                    p_dc_intersect = {}
                    for j in dc_gate_sequence.keys():
                        gt_dc = dc_gate_sequence[j][idx]
                        if gt_dc == 'p':
                            itr = 0
                            for item in plunger_tup_lengths:
                                if j == item[0]:
                                    p_dc_intersect[itr] = item[1]

                                else:
                                    itr += 1
                        else:
                            pass
                    p_dc_diff_max_idx = max(p_dc_intersect, key=p_dc_intersect.get)

                    if len(p_gates_other) == 0 and len(pi_2_intersect) == 0 and len(pi_intersect) == 0:
                        itr = 0
                        for item in plunger_tup_lengths:
                            if dc_idx == item[0]:
                                break
                            else:
                                itr += 1
                        if dc_idx%2 != 0:
                            ct_idx_p = itr
                        else:
                            ct_idx_p = itr + N_p
                        ct_idxs[awg_idx][core_idx][idx] = ct_idx_p
                    elif len(p_gates_other) != 0 and len(pi_2_intersect) == 0 and len(pi_intersect) == 0:
                        itr = 0
                        for item in plunger_tup_lengths:
                            if dc_idx == item[0]:
                                tau_p_gt = item[1]
                                break
                            else:
                                itr += 1

                        p_diff_taus = {}
                        for j in dc_gate_sequence.keys():
                            gt_dc = dc_gate_sequence[j][idx]
                            if gt_dc == 'p':
                                for item in plunger_tup_lengths:
                                    if j == item[0]:
                                        p_diff_taus[j] = item[1]
                                        break
                                    else:
                                        pass
                            else:
                                pass
                        p_diff_max_idx = max(p_diff_taus, key=p_diff_taus.get)

                        itr_diff_idx = 0
                        for item in plunger_tup_lengths:
                            if p_diff_max_idx == item[0]:
                                break
                            else:
                                itr_diff_idx += 1

                        ## CH 1
                        if dc_idx%2 != 0:
                            if check_dc_p_channels[idx][dc_idx] == 0:
                                if dc_gate_sequence[dc_idx+1][idx] == 'p':
                                    ct_idx_p = itr_diff_idx + 2*N_p
                                    ct_idxs[awg_idx][core_idx][idx] = ct_idx_p

                                elif dc_gate_sequence[dc_idx+1][idx][0] == 't':
                                    ##only p1
                                    ct_idx_p = itr_diff_idx
                                    ct_idxs[awg_idx][core_idx][idx] =  ct_idx_p

                                else:
                                    ##Throw error instead
                                    pass
                                check_dc_p_channels[idx][dc_idx] += 1
                                check_dc_p_channels[idx][dc_idx+1] += 1
                            else:
                               pass


                       ## CH 2
                        elif dc_idx%2 == 0:
                            if check_dc_p_channels[idx][dc_idx] == 0:
                                if dc_gate_sequence[dc_idx-1][idx] == 'p':
                                    ##p1, p2 simulataneous
                                    ct_idx_p = itr_diff_idx + 2*N_p
                                    ct_idxs[awg_idx][core_idx][idx] = ct_idx_p

                                elif dc_gate_sequence[dc_idx-1][idx][0] == 't':
                                    ##only p2
                                    ct_idx_p = itr_diff_idx + N_p
                                    ct_idxs[awg_idx][core_idx][idx] = ct_idx_p
                                else:
                                    ##Throw error instead
                                    pass
                                check_dc_p_channels[idx][dc_idx] += 1
                                check_dc_p_channels[idx][dc_idx-1] += 1
                            else:
                               pass
                        else:
                            pass

                    ##Case 4
                    elif len(pi_intersect) != 0:
                        if p_dc_intersect[p_dc_diff_max_idx] > taus_std[1]:
                            use_p_std = 1
                        else:
                            use_p_std = 0

                        ##Work in p std frame
                        if use_p_std == 1:
                            ##CH 1
                            if dc_idx%2 != 0:
                                if check_dc_p_channels[idx][dc_idx] == 0:
                                    if dc_gate_sequence[dc_idx+1][idx] == 'p':
                                        ##p1, p2 simulataneous in p std frame
                                        ct_idx_p = p_std_idx + 2*N_p
                                        ct_idxs[awg_idx][core_idx][idx] = ct_idx_p

                                    elif dc_gate_sequence[dc_idx+1][idx][0] == 't':
                                        ##only p1 in p std frame
                                        ct_idx_p = p_std_idx
                                        ct_idxs[awg_idx][core_idx][idx] = ct_idx_p

                                    else:
                                        ##Throw error instead
                                        pass
                                    check_dc_p_channels[idx][dc_idx] += 1
                                    check_dc_p_channels[idx][dc_idx+1] += 1
                                else:
                                   pass


                           ## CH 2
                            elif dc_idx%2 == 0:
                                ## Check if index already generated for the other channel
                                if check_dc_p_channels[idx][dc_idx] == 0:
                                    if dc_gate_sequence[dc_idx-1][idx] == 'p':
                                        ##p1, p2 simulataneous in p frmae
                                        ct_idx_p = p_std_idx + 2*N_p
                                        ct_idxs[awg_idx][core_idx][idx] = ct_idx_p
                                    elif dc_gate_sequence[dc_idx-1][idx][0] == 't':
                                        ##only p2 in pi frame
                                        ct_idx_p = N_p + p_std_idx
                                        ct_idxs[awg_idx][core_idx][idx] = ct_idx_p

                                    else:
                                        ##Throw error instead
                                        pass
                                    check_dc_p_channels[idx][dc_idx] += 1
                                    check_dc_p_channels[idx][dc_idx-1] += 1
                                else:
                                   pass

                            else:
                                pass


                        else:
                            ## PI frame
                            ##CH 1
                            if dc_idx%2 != 0:
                                ## Check if index already generated for the other channel
                                if check_dc_p_channels[idx][dc_idx] == 0:
                                    if dc_gate_sequence[dc_idx+1][idx] == 'p':
                                        ##p1, p2 simulataneous in pi frame
                                        ct_idx_p = 3*N_p + 4
                                        ct_idxs[awg_idx][core_idx][idx] = ct_idx_p

                                    elif dc_gate_sequence[dc_idx+1][idx][0] == 't':
                                        ##only p1
                                        ct_idx_p = 3*N_p
                                        ct_idxs[awg_idx][core_idx][idx] = ct_idx_p

                                    else:
                                        ##Throw error instead
                                        pass
                                    check_dc_p_channels[idx][dc_idx] += 1
                                    check_dc_p_channels[idx][dc_idx+1] += 1
                                else:
                                   pass

                           ## CH 2
                            elif dc_idx%2 == 0:
                                ## Check if index already generated for the other channel
                                if check_dc_p_channels[idx][dc_idx] == 0:
                                    if dc_gate_sequence[dc_idx-1][idx] == 'p':
                                        ##p1, p2 simulataneous
                                        ct_idx_p = 3*N_p + 4
                                        ct_idxs[awg_idx][core_idx][idx] = ct_idx_p
                                    elif dc_gate_sequence[dc_idx-1][idx][0] == 't':
                                        ##only p2
                                        ct_idx_p = 3*N_p + 1
                                        ct_idxs[awg_idx][core_idx][idx] = ct_idx_p
                                    else:
                                        ##Throw error instead
                                        pass
                                    check_dc_p_channels[idx][dc_idx] += 1
                                    check_dc_p_channels[idx][dc_idx-1] += 1
                                else:
                                   pass

                            else:
                                pass

                    #Case 5: working in  pi/2 frame
                    elif len(pi_2_intersect) != 0 and len(pi_intersect) == 0:
                        if p_dc_intersect[p_dc_diff_max_idx] > taus_std[0]:
                            use_p_std = 1
                        else:
                            use_p_std = 0

                        ##Work in p std frame
                        if use_p_std == 1:
                            ##CH 1
                            if dc_idx%2 != 0:
                                ## Check if index already generated for the other channel
                                if check_dc_p_channels[idx][dc_idx] == 0:
                                    if dc_gate_sequence[dc_idx+1][idx] == 'p':
                                        ##p1, p2 simulataneous in p std frame
                                        ct_idx_p = p_std_idx + 2*N_p
                                        ct_idxs[awg_idx][core_idx][idx] = ct_idx_p

                                    elif dc_gate_sequence[dc_idx+1][idx][0] == 't':
                                        ##only p1 in p std frame
                                        ct_idx_p = p_std_idx
                                        ct_idxs[awg_idx][core_idx][idx] = ct_idx_p

                                    else:
                                        ##Throw error instead
                                        pass
                                    check_dc_p_channels[idx][dc_idx] += 1
                                    check_dc_p_channels[idx][dc_idx+1] += 1
                                else:
                                   pass


                           ## CH 2
                            elif dc_idx%2 == 0:
                                ## Check if index already generated for the other channel
                                if check_dc_p_channels[idx][dc_idx] == 0:
                                    if dc_gate_sequence[dc_idx-1][idx] == 'p':
                                        ##p1, p2 simulataneous in p frmae
                                        ct_idx_p = p_std_idx + 2*N_p
                                        ct_idxs[awg_idx][core_idx][idx] = ct_idx_p
                                    elif dc_gate_sequence[dc_idx-1][idx][0] == 't':
                                        ##only p2 in pi frame
                                        ct_idx_p = N_p + p_std_idx
                                        ct_idxs[awg_idx][core_idx][idx] = ct_idx_p

                                    else:
                                        ##Throw error instead
                                        pass
                                    check_dc_p_channels[idx][dc_idx] += 1
                                    check_dc_p_channels[idx][dc_idx-1] += 1
                                else:
                                   pass

                            else:
                                pass


                        else:
                            ## PI/2 frame
                            ##CH 1
                            if dc_idx%2 != 0:
                                ## Check if index already generated for the other channel
                                if check_dc_p_channels[idx][dc_idx] == 0:
                                    if dc_gate_sequence[dc_idx+1][idx] == 'p':
                                        ##p1, p2 simulataneous in pi/2 frame
                                        ct_idx_p = 3*N_p + 5
                                        ct_idxs[awg_idx][core_idx][idx] = ct_idx_p

                                    elif dc_gate_sequence[dc_idx+1][idx][0] == 't':
                                        ##only p1
                                        ct_idx_p = 3*N_p + 2
                                        ct_idxs[awg_idx][core_idx][idx] = ct_idx_p

                                    else:
                                        ##Throw error instead
                                        pass
                                    check_dc_p_channels[idx][dc_idx] += 1
                                    check_dc_p_channels[idx][dc_idx+1] += 1
                                else:
                                   pass

                           ## CH 2
                            elif dc_idx%2 == 0:
                                ## Check if index already generated for the other channel
                                if check_dc_p_channels[idx][dc_idx] == 0:
                                    if dc_gate_sequence[dc_idx-1][idx] == 'p':
                                        ##p1, p2 simulataneous
                                        ct_idx_p = 3*N_p + 5
                                        ct_idxs[awg_idx][core_idx][idx] = ct_idx_p
                                    elif dc_gate_sequence[dc_idx-1][idx][0] == 't':
                                        ##only p2
                                        ct_idx_p = 3*N_p + 3
                                        ct_idxs[awg_idx][core_idx][idx] = ct_idx_p
                                    else:
                                        ##Throw error instead
                                        pass
                                    check_dc_p_channels[idx][dc_idx] += 1
                                    check_dc_p_channels[idx][dc_idx-1] += 1
                                else:
                                   pass

                            else:
                                pass

                elif gt == 'z0z':
                    ct_idxs[awg_idx][core_idx][idx] = ct_idx_p_z0z

                elif gt[0] == 't':
                    if dc_idx%2 != 0:
                        if dc_gate_sequence[dc_idx+1][idx][0] != 't':
                            dual_channel = 0
                        else:
                            dual_channel = 1
                    else:
                        if dc_gate_sequence[dc_idx-1][idx][0] != 't':
                            dual_channel = 0
                        else:
                            dual_channel = 1

                    if dual_channel == 0:
                        pass
                    else:
                        gt_t_str = int(gt[1:len(gt)])
                        ## pi delays
                        if gt_t_str == int(taus_std[1]):
                            ct_idxs[awg_idx][core_idx][idx] = ct_p_idx_tau_pi
                        # std pi/2 delays
                        elif gt_t_str == int(taus_std[0]):
                            ct_idxs[awg_idx][core_idx][idx] = ct_p_idx_tau_pi_2

                        # plunger delays
                        else:
                            if gt_t_str in plunger_len_set:
                                idx_t_p = 0
                                for itm in plunger_len_tups:
                                    idx_t_p += 1
                                    if gt_t_str == itm[1]:
                                        ct_idx_t_p  = ct_p_idx_tau_p_std + idx_t_p
                                        ct_idxs[awg_idx][core_idx][idx] = ct_idx_t_p
                                        break
                                    else:
                                        continue

                            elif gt_t_str in set(arb_gate_taus):
                                idx_a = 0
                                for itm in arb_gate_taus:
                                    idx_a += 1
                                    if gt_t_str == itm:
                                        ct_idx_t_a =  ct_p_idx_tau_p_std+ N_p+idx_a
                                        ct_idxs[awg_idx][core_idx][idx] = ct_idx_t_a
                                        break
                                    else:
                                        continue
                            else:
                                pass

                elif gt.find('*') != -1:
                    if gt[gt.find('*')+1] in arbgate_dict.keys():
                        ## PI/2 frame
                        ##CH 1
                        if dc_idx%2 != 0:
                            if check_dc_p_channels[idx][dc_idx] == 0:
                                ct_idx_t_a = ct_p_idx_tau_p_std+ N_p+len(arb_gate_taus) + arb_dc_dict[awg_idx][core_idx][line][idx][1]
                                ct_idxs[awg_idx][core_idx][idx] = ct_idx_t_a
                                check_dc_p_channels[idx][dc_idx] += 1
                                check_dc_p_channels[idx][dc_idx+1] += 1
                            else:
                               pass

                       ## CH 2
                        elif dc_idx%2 == 0:
                            if check_dc_p_channels[idx][dc_idx] == 0:
                                ct_idx_t_a = ct_p_idx_tau_p_std+ N_p+len(arb_gate_taus) + arb_dc_dict[awg_idx][core_idx][line][idx][1]
                                ct_idxs[awg_idx][core_idx][idx] = ct_idx_t_a
                                check_dc_p_channels[idx][dc_idx] += 1
                                check_dc_p_channels[idx][dc_idx-1] += 1
                            else:
                               pass

                        else:
                            pass
                    else:
                        pass
            else:
                continue
    return ct_idxs, arbgate_counter

def make_rf_command_table(n_std, arbZs, arbitrary_waveforms, plunger_length_set, awgidx, coreidx, awg):

    ct = CommandTable(awg.commandtable.load_validation_schema())
    n_pi_2_std = n_std[0]
    n_pi_std = n_std[1]
    n_p_std = n_std[2]

    initial_gates = {"xx_pi_fr": {"phi": 0, "wave_idx": 0}, "yy_pi_fr": {"phi": -90, "wave_idx": 0}, "mxxm_pi_fr": {"phi": -180, "wave_idx": 0}, "myym_pi_fr": {"phi": 90, "wave_idx": 0},
    "x_pi_2_fr": {"phi": 0, "wave_idx": 1},  "y_pi_2_fr": {"phi": -90, "wave_idx": 1},  "xxx_pi_2_fr": {"phi": -180, "wave_idx": 1},  "yyy_pi_2_fr": {"phi": 90, "wave_idx": 1},
    "x_pi_fr": {"phi": 0, "wave_idx": 2},  "y_pi_fr": {"phi": -90, "wave_idx": 2},  "xxx_pi_fr": {"phi": -180, "wave_idx": 2},  "yyy_pi_fr": {"phi": 90, "wave_idx": 2},
    "xx_p_fr": {"phi": 0, "wave_idx": 3}, "yy_p_fr": {"phi": -90, "wave_idx": 3}, "mxxm_p_fr": {"phi": -180, "wave_idx": 3}, "myym_p_fr": {"phi": 90, "wave_idx": 3},
    "x_p_fr": {"phi": 0, "wave_idx": 4},  "y_p_fr": {"phi": -90, "wave_idx": 4},  "xxx_p_fr": {"phi": -180, "wave_idx": 4},  "yyy_p_fr": {"phi": 90, "wave_idx": 4}}
    #Waves
    #0- (pi)_pi
    #1- (pi/2)_pi/2
    #2- (pi/2)_pi
    #3- (pi)_p
    #4- (pi/2)_p
    waves = [{"index": 0, "awgChannel0": ["sigout0","sigout1"]}, {"index": 1, "awgChannel0": ["sigout0","sigout1"]},  {"index": 2, "awgChannel0": ["sigout0","sigout1"]}, {"index": 3, "awgChannel0": ["sigout0","sigout1"]}, {"index": 4, "awgChannel0": ["sigout0","sigout1"]}]
    phases_0_I = [{"value": 0, "increment": False}, {"value": 90, "increment": False}, {"value": 180, "increment": False}, {"value": 90, "increment": False}]
    phases_0_Q = [{"value": 90, "increment": False}, {"value": 180, "increment": False}, {"value": 270, "increment": False}, {"value": 0, "increment": False}]
    phases_incr = [{"value": 0, "increment": True}, {"value": -90, "increment": True}, {"value": -180, "increment": True}, {"value": -270, "increment": True}, {"value": 90, "increment": True},  {"value": 180, "increment": True},{"value": 270, "increment": True}]
    ct_idx = 0
    ## Initial (pi)_pi gates
    for i in range(len(phases_0_I)):
        ct.table[ct_idx].waveform.index = waves[0]['index']
        ct.table[ct_idx].amplitude0.value = 1
        ct.table[ct_idx].amplitude0.increment = False
        ct.table[ct_idx].amplitude1.value = 1
        ct.table[ct_idx].amplitude1.increment = False
        ct.table[ct_idx].phase0.value = phases_0_I[i]['value']
        ct.table[ct_idx].phase0.increment = False
        ct.table[ct_idx].phase1.value = phases_0_Q[i]['value']
        ct.table[ct_idx].phase1.increment = False
        ct_idx += 1
    ## Initial (pi/2)_pi/2 gates
    for i in range(len(phases_0_I)):
        ct.table[ct_idx].waveform.index = waves[1]['index']
        ct.table[ct_idx].amplitude0.value = 1
        ct.table[ct_idx].amplitude0.increment = False
        ct.table[ct_idx].amplitude1.value = 1
        ct.table[ct_idx].amplitude1.increment = False
        ct.table[ct_idx].phase0.value = phases_0_I[i]['value']
        ct.table[ct_idx].phase0.increment = False
        ct.table[ct_idx].phase1.value = phases_0_Q[i]['value']
        ct.table[ct_idx].phase1.increment = False
        ct_idx += 1

    ## Initial (pi/2)_pi gates
    for i in range(len(phases_0_I)):
        ct.table[ct_idx].waveform.index = waves[2]['index']
        ct.table[ct_idx].amplitude0.value = 1
        ct.table[ct_idx].amplitude0.increment = False
        ct.table[ct_idx].amplitude1.value = 1
        ct.table[ct_idx].amplitude1.increment = False
        ct.table[ct_idx].phase0.value = phases_0_I[i]['value']
        ct.table[ct_idx].phase0.increment = False
        ct.table[ct_idx].phase1.value = phases_0_Q[i]['value']
        ct.table[ct_idx].phase1.increment = False
        ct_idx += 1

    ## Initial (pi)_p gates
    for i in range(len(phases_0_I)):
        ct.table[ct_idx].waveform.index = waves[3]['index']
        ct.table[ct_idx].amplitude0.value = 1
        ct.table[ct_idx].amplitude0.increment = False
        ct.table[ct_idx].amplitude1.value = 1
        ct.table[ct_idx].amplitude1.increment = False
        ct.table[ct_idx].phase0.value = phases_0_I[i]['value']
        ct.table[ct_idx].phase0.increment = False
        ct.table[ct_idx].phase1.value = phases_0_Q[i]['value']
        ct.table[ct_idx].phase1.increment = False
        ct_idx += 1

    ## Initial (pi/2)_p gates
    for i in range(len(phases_0_I)):
        ct.table[ct_idx].waveform.index = waves[4]['index']
        ct.table[ct_idx].amplitude0.value = 1
        ct.table[ct_idx].amplitude0.increment = False
        ct.table[ct_idx].amplitude1.value = 1
        ct.table[ct_idx].amplitude1.increment = False
        ct.table[ct_idx].phase0.value = phases_0_I[i]['value']
        ct.table[ct_idx].phase0.increment = False
        ct.table[ct_idx].phase1.value = phases_0_Q[i]['value']
        ct.table[ct_idx].phase1.increment = False
        ct_idx += 1

    ## Incremented (pi)_pi gates
    for i in range(len(phases_incr)):
        ct.table[ct_idx].waveform.index = waves[0]['index']
        ct.table[ct_idx].amplitude0.value = 1
        ct.table[ct_idx].amplitude0.increment = False
        ct.table[ct_idx].amplitude1.value = 1
        ct.table[ct_idx].amplitude1.increment = False
        ct.table[ct_idx].phase0.value = phases_incr[i]['value']
        ct.table[ct_idx].phase0.increment = True
        ct.table[ct_idx].phase1.value = phases_incr[i]['value']
        ct.table[ct_idx].phase1.increment = True
        ct_idx += 1

    ## Incremented (pi/2)_pi/2 gates
    for i in range(len(phases_incr)):
        ct.table[ct_idx].waveform.index = waves[1]['index']
        ct.table[ct_idx].amplitude0.value = 1
        ct.table[ct_idx].amplitude0.increment = False
        ct.table[ct_idx].amplitude1.value = 1
        ct.table[ct_idx].amplitude1.increment = False
        ct.table[ct_idx].phase0.value = phases_incr[i]['value']
        ct.table[ct_idx].phase0.increment = True
        ct.table[ct_idx].phase1.value = phases_incr[i]['value']
        ct.table[ct_idx].phase1.increment = True
        ct_idx += 1
    ## Incremented (pi/2)_pi gates
    for i in range(len(phases_incr)):
        ct.table[ct_idx].waveform.index = waves[2]['index']
        ct.table[ct_idx].amplitude0.value = 1
        ct.table[ct_idx].amplitude0.increment = False
        ct.table[ct_idx].amplitude1.value = 1
        ct.table[ct_idx].amplitude1.increment = False
        ct.table[ct_idx].phase0.value = phases_incr[i]['value']
        ct.table[ct_idx].phase0.increment = True
        ct.table[ct_idx].phase1.value = phases_incr[i]['value']
        ct.table[ct_idx].phase1.increment = True
        ct_idx += 1
    ## Incremented (pi)_p gates
    for i in range(len(phases_incr)):
        ct.table[ct_idx].waveform.index = waves[3]['index']
        ct.table[ct_idx].amplitude0.value = 1
        ct.table[ct_idx].amplitude0.increment = False
        ct.table[ct_idx].amplitude1.value = 1
        ct.table[ct_idx].amplitude1.increment = False
        ct.table[ct_idx].phase0.value = phases_incr[i]['value']
        ct.table[ct_idx].phase0.increment = True
        ct.table[ct_idx].phase1.value = phases_incr[i]['value']
        ct.table[ct_idx].phase1.increment = True
        ct_idx += 1

    ## Incremented (pi/2)_p gates
    for i in range(len(phases_incr)):
        ct.table[ct_idx].waveform.index = waves[4]['index']
        ct.table[ct_idx].amplitude0.value = 1
        ct.table[ct_idx].amplitude0.increment = False
        ct.table[ct_idx].amplitude1.value = 1
        ct.table[ct_idx].amplitude1.increment = False
        ct.table[ct_idx].phase0.value = phases_incr[i]['value']
        ct.table[ct_idx].phase0.increment = True
        ct.table[ct_idx].phase1.value = phases_incr[i]['value']
        ct.table[ct_idx].phase1.increment = True
        ct_idx += 1

    ##Z0Z table entry
    ct.table[ct_idx].phase0.value = 0
    ct.table[ct_idx].phase0.increment = True
    ct.table[ct_idx].phase1.value = 0
    ct.table[ct_idx].phase1.increment = True
    ct_idx += 1

    ##Arbitrary Z gates to follow
    if len(arbZs) == 0:
        pass
    else:
        for arbZ in arbZs[awgidx][coreidx]:
            phase = arbZs[awgidx][coreidx][arbZ][1]
            ct.table[ct_idx].phase0.value = phase
            ct.table[ct_idx].phase0.increment = True
            ct.table[ct_idx].phase1.value = phase
            ct.table[ct_idx].phase1.increment = True
            ct_idx += 1

    ##Standard pulse delays
    ct.table[ct_idx].waveform.playZero = True
    ct.table[ct_idx].waveform.length = n_pi_std
    ct_idx += 1

    ct.table[ct_idx].waveform.playZero = True
    ct.table[ct_idx].waveform.length = n_pi_2_std
    ct_idx += 1

    ct.table[ct_idx].waveform.playZero = True
    ct.table[ct_idx].waveform.length = n_p_std
    ct_idx += 1

    #Plunger pulse delays
    for p in plunger_length_set:
        ct.table[ct_idx].waveform.playZero = True
        ct.table[ct_idx].waveform.length = p[1]
        ct_idx += 1

    for awg_idx in arbitrary_waveforms:
        for core_idx in arbitrary_waveforms[awg_idx]:
            if len(arbitrary_waveforms[awg_idx][core_idx]) == 0:
                pass
            else:
                for i in range(len(arbitrary_waveforms[awg_idx][core_idx])):
                    ct.table[ct_idx].waveform.playZero = True
                    ct.table[ct_idx].waveform.length = len(arbitrary_waveforms[awg_idx][core_idx][i][1])
                    gate_str = arbitrary_waveforms[awg_idx][core_idx][i][0]
                    ct_idx += 1

    arb_rf_pulses = arbitrary_waveforms[awgidx][coreidx]

    if len(arb_rf_pulses) == 0:
        pass
    else:
        wave_idx = 5
        for wave in arb_rf_pulses:
            ## Add exception for arb T gate
            gate_str = wave[0]
            amplitude = float(gate_str[0:gate_str.find('*')])
            amb_idxs = [i for i, letter in enumerate(gate_str) if letter == '&']
            phase = float(gate_str[amb_idxs[0]+1:amb_idxs[1]])
            if wave[0][wave[0].find('*')+1:wave[0].find('[')] in {'X', 'Y', 'U', 'V'}:
                ct.table[ct_idx].waveform.index = wave_idx
                ct.table[ct_idx].amplitude0.value = amplitude
                ct.table[ct_idx].amplitude0.increment = False
                ct.table[ct_idx].amplitude1.value = amplitude
                ct.table[ct_idx].amplitude1.increment = False
                ct.table[ct_idx].phase0.value =  phase
                ct.table[ct_idx].phase0.increment = False
                ct.table[ct_idx].phase1.value = (phase+90)
                ct.table[ct_idx].phase1.increment =False
                ct_idx += 1

                ct.table[ct_idx].waveform.index = wave_idx
                ct.table[ct_idx].amplitude0.value = amplitude
                ct.table[ct_idx].amplitude0.increment = False
                ct.table[ct_idx].amplitude1.value = amplitude
                ct.table[ct_idx].amplitude1.increment = False
                ct.table[ct_idx].phase0.value =  (phase+90)
                ct.table[ct_idx].phase0.increment = False
                ct.table[ct_idx].phase1.value = (phase+180)
                ct.table[ct_idx].phase1.increment = False
                ct_idx += 1

                ct.table[ct_idx].waveform.index = wave_idx
                ct.table[ct_idx].amplitude0.value = amplitude
                ct.table[ct_idx].amplitude0.increment = False
                ct.table[ct_idx].amplitude1.value = amplitude
                ct.table[ct_idx].amplitude1.increment = False
                ct.table[ct_idx].phase0.value = (phase+180)
                ct.table[ct_idx].phase0.increment = False
                ct.table[ct_idx].phase1.value = (phase+270)
                ct.table[ct_idx].phase1.increment = False
                ct_idx += 1

                ct.table[ct_idx].waveform.index = wave_idx
                ct.table[ct_idx].amplitude0.value = amplitude
                ct.table[ct_idx].amplitude0.increment = False
                ct.table[ct_idx].amplitude1.value = amplitude
                ct.table[ct_idx].amplitude1.increment = False
                ct.table[ct_idx].phase0.value =  phase+90
                ct.table[ct_idx].phase0.increment = False
                ct.table[ct_idx].phase1.value = phase
                ct.table[ct_idx].phase1.increment = False
                ct_idx += 1

                ct.table[ct_idx].waveform.index = wave_idx
                ct.table[ct_idx].amplitude0.value = amplitude
                ct.table[ct_idx].amplitude0.increment = False
                ct.table[ct_idx].amplitude1.value = amplitude
                ct.table[ct_idx].amplitude1.increment = False
                ct.table[ct_idx].phase0.value =  -phase
                ct.table[ct_idx].phase0.increment = True
                ct.table[ct_idx].phase1.value = -phase
                ct.table[ct_idx].phase1.increment = True
                ct_idx += 1

                ct.table[ct_idx].waveform.index = wave_idx
                ct.table[ct_idx].amplitude0.value = amplitude
                ct.table[ct_idx].amplitude0.increment = False
                ct.table[ct_idx].amplitude1.value = amplitude
                ct.table[ct_idx].amplitude1.increment = False
                ct.table[ct_idx].phase0.value =  phase
                ct.table[ct_idx].phase0.increment = True
                ct.table[ct_idx].phase1.value = phase
                ct.table[ct_idx].phase1.increment = True
                ct_idx += 1

                ct.table[ct_idx].waveform.index = wave_idx
                ct.table[ct_idx].amplitude0.value = amplitude
                ct.table[ct_idx].amplitude0.increment = False
                ct.table[ct_idx].amplitude1.value = amplitude
                ct.table[ct_idx].amplitude1.increment = False
                ct.table[ct_idx].phase0.value =  -(phase+90)
                ct.table[ct_idx].phase0.increment = True
                ct.table[ct_idx].phase1.value = -(phase+90)
                ct.table[ct_idx].phase1.increment = True
                ct_idx += 1

                ct.table[ct_idx].waveform.index = wave_idx
                ct.table[ct_idx].amplitude0.value = amplitude
                ct.table[ct_idx].amplitude0.increment = False
                ct.table[ct_idx].amplitude1.value = amplitude
                ct.table[ct_idx].amplitude1.increment = False
                ct.table[ct_idx].phase0.value =  -(phase+180)
                ct.table[ct_idx].phase0.increment = True
                ct.table[ct_idx].phase1.value = -(phase+180)
                ct.table[ct_idx].phase1.increment = True
                ct_idx += 1

                ct.table[ct_idx].waveform.index = wave_idx
                ct.table[ct_idx].amplitude0.value = amplitude
                ct.table[ct_idx].amplitude0.increment = False
                ct.table[ct_idx].amplitude1.value = amplitude
                ct.table[ct_idx].amplitude1.increment = False
                ct.table[ct_idx].phase0.value =  -(phase+270)
                ct.table[ct_idx].phase0.increment = True
                ct.table[ct_idx].phase1.value = -(phase+270)
                ct.table[ct_idx].phase1.increment = True
                ct_idx += 1

                ct.table[ct_idx].waveform.index = wave_idx
                ct.table[ct_idx].amplitude0.value = amplitude
                ct.table[ct_idx].amplitude0.increment = False
                ct.table[ct_idx].amplitude1.value = amplitude
                ct.table[ct_idx].amplitude1.increment = False
                ct.table[ct_idx].phase0.value =  -(phase-90)
                ct.table[ct_idx].phase0.increment = True
                ct.table[ct_idx].phase1.value = -(phase-90)
                ct.table[ct_idx].phase1.increment = True
                ct_idx += 1

                ct.table[ct_idx].waveform.index = wave_idx
                ct.table[ct_idx].amplitude0.value = amplitude
                ct.table[ct_idx].amplitude0.increment = False
                ct.table[ct_idx].amplitude1.value = amplitude
                ct.table[ct_idx].amplitude1.increment = False
                ct.table[ct_idx].phase0.value =  -(phase-180)
                ct.table[ct_idx].phase0.increment = True
                ct.table[ct_idx].phase1.value = -(phase-180)
                ct.table[ct_idx].phase1.increment = True
                ct_idx += 1

                ct.table[ct_idx].waveform.index = wave_idx
                ct.table[ct_idx].amplitude0.value = amplitude
                ct.table[ct_idx].amplitude0.increment = False
                ct.table[ct_idx].amplitude1.value = amplitude
                ct.table[ct_idx].amplitude1.increment = False
                ct.table[ct_idx].phase0.value =  -(phase-270)
                ct.table[ct_idx].phase0.increment = True
                ct.table[ct_idx].phase1.value = -(phase-270)
                ct.table[ct_idx].phase1.increment = True
                ct_idx += 1

            else:
                ct.table[ct_idx].waveform.index = wave_idx
                ct.table[ct_idx].amplitude0.value = amplitude
                ct.table[ct_idx].amplitude0.increment = False
                ct.table[ct_idx].amplitude1.value = amplitude
                ct.table[ct_idx].amplitude1.increment = False
                ct.table[ct_idx].phase0.value =  -(phase)
                ct.table[ct_idx].phase0.increment = True
                ct.table[ct_idx].phase1.value = -(phase)
                ct.table[ct_idx].phase1.increment = True
                ct_idx += 1
            wave_idx += 1
    return ct


def make_dc_command_table(n_std, arbitrary_waveforms, plunger_length_tups, awgidx, coreidx, arb_dc_waveforms, awg):
    ct = CommandTable(awg.commandtable.load_validation_schema())
    n_pi_2_std = n_std[0]
    n_pi_std = n_std[1]
    n_p_std = n_std[2]
    ct_idx = 0
    wave_idx = 0

    ##1. [(p_1)_1, 0] - [(p_1)_N, 0]
    for i in range(len(plunger_length_tups)):
        ct.table[ct_idx].waveform.index = wave_idx
        wave_idx += 1
        ct_idx += 1

    ##2. [0, (p_2)_1] -  [0, (p_2)_N]
    for i in range(len(plunger_length_tups)):
        ct.table[ct_idx].waveform.index = wave_idx
        wave_idx += 1
        ct_idx += 1

    ##3. [(p_1)_1, (p_2)_1] -  [(p_1)_N, (p_2)_N]
    for i in range(len(plunger_length_tups)):
        ct.table[ct_idx].waveform.index = wave_idx
        wave_idx += 1
        ct_idx += 1

    ## 4. [(p_1)_pi, 0],  [0, (p_2)_pi]
    ct.table[ct_idx].waveform.index = wave_idx
    wave_idx += 1
    ct_idx += 1
    ct.table[ct_idx].waveform.index = wave_idx
    wave_idx += 1
    ct_idx += 1

    ## 5. [(p_1)_pi/2, 0],  [0, (p_2)_pi/2]
    ct.table[ct_idx].waveform.index = wave_idx
    wave_idx += 1
    ct_idx += 1
    ct.table[ct_idx].waveform.index = wave_idx
    wave_idx += 1
    ct_idx += 1

    ## 6. [(p_1)_pi, (p_2)_pi], [(p_1)_pi/2, (p_2)_pi/2]
    ct.table[ct_idx].waveform.index = wave_idx
    wave_idx += 1
    ct_idx += 1
    ct.table[ct_idx].waveform.index = wave_idx
    wave_idx += 1
    ct_idx += 1

    ##8. Z0Z
    ct.table[ct_idx].phase0.value = 0
    ct.table[ct_idx].phase0.increment = True
    ct.table[ct_idx].phase1.value = 0
    ct.table[ct_idx].phase1.increment = True
    ct_idx += 1

    ##9. tau_pi
    ct.table[ct_idx].waveform.playZero = True
    ct.table[ct_idx].waveform.length = n_pi_std
    ct_idx += 1

    ##10. tau_pi/2
    ct.table[ct_idx].waveform.playZero = True
    ct.table[ct_idx].waveform.length = n_pi_2_std
    ct_idx += 1

    ##11. tau_p_std
    ct.table[ct_idx].waveform.playZero = True
    ct.table[ct_idx].waveform.length = n_p_std
    ct_idx += 1

    ##12. tau_p_1 - tau_p_N
    for p in plunger_length_tups:
        ct.table[ct_idx].waveform.playZero = True
        ct.table[ct_idx].waveform.length = p[1]
        ct_idx += 1

    ##13. Arb waveform delays
    for awg_idx in arbitrary_waveforms:
        for core_idx in arbitrary_waveforms[awg_idx]:
            if len(arbitrary_waveforms[awg_idx][core_idx]) == 0:
                pass
            else:
                for i in range(len(arbitrary_waveforms[awg_idx][core_idx])):
                    ct.table[ct_idx].waveform.playZero = True
                    ct.table[ct_idx].waveform.length = len(arbitrary_waveforms[awg_idx][core_idx][i][1])
                    ct_idx += 1

    ##14. Arb waveforms
    for line in arb_dc_waveforms[awgidx][coreidx]:
        for idx in arb_dc_waveforms[awgidx][coreidx][line]:
            if len(arb_dc_waveforms[awgidx][coreidx][line][idx]) != 0:
                gate_tuple = arb_dc_waveforms[awgidx][coreidx][line][idx]
                if gate_tuple[0][0] != 't' and gate_tuple[1][0] != 't':
                    amplitude_1 = float(gate_tuple[0][0:gate_tuple[0].find('*')])
                    amplitude_2 = float(gate_tuple[1][0:gate_tuple[1].find('*')])
                    ct.table[ct_idx].waveform.index = wave_idx
                    ct_idx += 1
                    wave_idx += 1

                elif gate_tuple[0][0] != 't' and gate_tuple[1][0] == 't':
                    amplitude_1 = float(gate_tuple[0][0:gate_tuple[0].find('*')])
                    amplitude_2 = float(gate_tuple[0][0:gate_tuple[0].find('*')])
                    ct.table[ct_idx].waveform.index = wave_idx
                    ct_idx += 1
                    wave_idx += 1
                elif gate_tuple[0][0] == 't' and gate_tuple[1][0] != 't':
                    amplitude_1 = float(gate_tuple[1][0:gate_tuple[1].find('*')])
                    amplitude_2 = float(gate_tuple[1][0:gate_tuple[1].find('*')])
                    ct.table[ct_idx].waveform.index = wave_idx
                    ct_idx += 1
                    wave_idx += 1
                else:
                    ##Instead throw an error here
                    pass
            else:
                continue
    return ct

def make_waveform_placeholders(waveform_lengths):
    '''
    Generates sequencer code for waveform placeholders on HDAWG FPGAs.

    Parameters:
                n_array (list): list of the number of points used for each waveform. Note, that each element of n_array must be at least 48 and an integer multiple of 16.
    Returns:
       sequence_code (str): sequencer code for waveform placeholders.
    '''
    idx = 0
    sequence_code = ""
    for wave_idx in waveform_lengths:
        line = "assignWaveIndex(placeholder("+str(waveform_lengths[wave_idx][0])+"),"+"placeholder("+str(waveform_lengths[wave_idx][1])+"),"+str(wave_idx)+");\n"
        sequence_code = sequence_code + line
    return sequence_code

def make_waveform_placeholders_plungers(n_array):
    '''
    Generates sequencer code for plunger gate waveform placeholders on HDAWG FPGAs.

    Parameters:
                n_array (list): list of the number of points used for each waveform. Note, that each element of n_array must be at least 48 and an integer multiple of 16.
    Returns:
       sequence_code (str): sequencer code for waveform placeholders.
    '''
    idx = 0

    line_1 = "assignWaveIndex(placeholder("+str(n_array[0])+"),"+ "placeholder("+str(n_array[0])+"),"+"0"+");\n"
    line_2 = "assignWaveIndex(placeholder("+str(n_array[1])+"),"+ "placeholder("+str(n_array[1])+"),"+"1"+");\n"
    line_3 = "assignWaveIndex(placeholder("+str(n_array[2])+"),"+ "placeholder("+str(n_array[3])+"),"+"2"+");\n"
    line_4 = "assignWaveIndex(placeholder("+str(n_array[2])+"),"+ "placeholder("+str(n_array[3])+"),"+"3"+");\n"
    line_5 = "assignWaveIndex(placeholder("+str(n_array[4])+"),"+ "placeholder("+str(n_array[4])+"),"+"4"+");\n"
    line_6 = "assignWaveIndex(placeholder("+str(n_array[5])+"),"+ "placeholder("+str(n_array[5])+"),"+"5"+");\n"
    line_7 = "assignWaveIndex(placeholder("+str(n_array[6])+"),"+ "placeholder("+str(n_array[6])+"),"+"6"+");\n"
    line_8 = "assignWaveIndex(placeholder("+str(n_array[7])+"),"+ "placeholder("+str(n_array[7])+"),"+"7"+");\n"
    line_9 = "assignWaveIndex(placeholder("+str(n_array[4])+"),"+ "placeholder("+str(n_array[5])+"),"+"8"+");\n"
    line_10 = "assignWaveIndex(placeholder("+str(n_array[6])+"),"+ "placeholder("+str(n_array[7])+"),"+"9"+");\n"
    sequence_code = line_1+line_2+line_3+line_4+line_5+line_6+line_7+line_8+line_9+line_10
    return sequence_code

def make_gateset_sequencer(n_seq, n_av, trig_channel=True):
    '''
    Generates sequencer code for waveform placeholders on HDAWG FPGAs.

    Parameters:
                n_array (list): list of the command table indices being executed on the AWG core.
                n_av (int): number of inner loops to iterate over during a GST run.
                trig_channel (bool): True if this core receives a physical trigger input, False otherwise.
    Returns:
       program (str): sequencer code for with command table executions for a given quantum algorithm.
    '''
    command_code = ""
    for n in n_seq:
        idx_str = str(n_seq[n])
        line = "executeTableEntry("+idx_str+");\n"
        command_code = command_code + line

    if trig_channel == True:
        trig_program = "repeat("+str(n_av)+"){"+"waitDigTrigger(1);\nsetDIO(1);wait(2);\nsetDIO(0);\nwaitDIOTrigger();\nresetOscPhase();\n"
    else:
        trig_program = "repeat("+str(n_av)+"){"+"\nwaitDIOTrigger();\nresetOscPhase();\n"
    program = trig_program + command_code +"}\n"
    return program


def make_gate_npoints(gate_parameters, sample_rate):
    '''
    Generates a dictionary with the number of poitns for each pulse type used in a quantum algorithm.

    Parameters:
                n_array (list): list of the command table indices being executed on the AWG core.
                sample_rate (float): sample rate of the HDAWG in samples per second.
    Returns:
       program (str): sequencer code for with command table executions for a given quantum algorithm.
    '''
    gate_npoints = {"rf": {}, "plunger": {}}
    for idx in gate_parameters["rf"]:
        n_pi = ceil(sample_rate*gate_parameters["rf"][idx]["tau_pi"]*1e-9/16)*16
        n_pi_2 = ceil(sample_rate*gate_parameters["rf"][idx]["tau_pi_2"]*1e-9/16)*16
        gate_npoints["rf"][idx] = {"pi": n_pi, "pi_2": n_pi_2}
    for idx in gate_parameters["p"]:
        n_p = ceil(sample_rate*gate_parameters["p"][idx]["tau"]*1e-9/16)*16
        gate_npoints["plunger"][idx] = {"p": n_p}
    return gate_npoints

def generate_waveforms(gate_npoints, channel_map, added_padding, standard_rf, n_std):
    '''
    Generates a dictionary with all waveforms to be uploaded on 4 AWG cores, provided the number of points for each gate, channel mapping, and additional uniform padding per gate. Waveforms generated in the form lists, accounting for all padding schemes. Additional padding adds delays uniformly to all gates in a sequenc. Padding on either side of gates not to exceed 5 ns.

    Outer elements keys of waveform dictionary correspond to AWG core index (from 1-4). Dedicated RF cores have keys corresponding to each waveform:
    - "pi_pifr", pi pulse in a pi frame
    - "pi_2_pi_2fr", pi/2 pulse in a pi/2 frame
    - "pi_2_pifr", pi/2 pulse in a pi frame

    Dedicated DC cores have keys corresponding to each waveform:\n
    - "pm_pmfr", (1 of these)
    - "pn_pnfr", (1 of these)
    - "pm_pjfr", (N-1 of these)
    - "pn_pjfr", (N-1 of these)

  ** m, n, i, j refers to channel indices [specifically for the DC channels].

    Parameters:
                gate_npoints (dict): dictionary of number of points per gate, per HDAWG
                channel_map (dict): channel mapping dictionary.
                added_padding (float): added padding to either side of a gate pulse, in ns.
    Returns:
       waveforms (dict): dictionary of waveforms to be uploaded on each core.
    '''

    plunger_channels = set({})
    for awg in channel_map:
        for core_idx in channel_map[awg]:
            if channel_map[awg][core_idx]['rf'] == 0:
                plunger_channels.add(channel_map[awg][core_idx]['gate_idx'][0])
                plunger_channels.add(channel_map[awg][core_idx]['gate_idx'][1])
            else:
                pass

    amp = 1
    ## Change amplitude parameter....
    waveforms = {}
    for awg in channel_map:
        waveforms[awg] = {}
        for core_idx in channel_map[awg]:
            if channel_map[awg][core_idx]['rf'] == 1:
                waveforms[awg][core_idx] = {"pi_pifr": None, "pi_2_pi_2fr": None, "pi_2_pifr":  None, 'pi_p_stdfr': None, 'pi_2_p_stdfr': None}
            elif channel_map[awg][core_idx]['rf'] == 0:
                waveforms[awg][core_idx] = {}
                ch_1_idx = channel_map[awg][core_idx]['gate_idx'][0]
                ch_2_idx = channel_map[awg][core_idx]['gate_idx'][1]
                waveforms[awg][core_idx]["p"+str(ch_1_idx)+"_pifr"] = None
                waveforms[awg][core_idx]["p"+str(ch_2_idx)+"_pifr"] = None
                waveforms[awg][core_idx]["p"+str(ch_1_idx)+"_pi_2fr"] = None
                waveforms[awg][core_idx]["p"+str(ch_2_idx)+"_pi_2fr"] = None
                for ch_idx in plunger_channels:
                    waveforms[awg][core_idx]["p"+str(ch_1_idx)+"_p"+str(ch_idx)+"fr"] = None
                    waveforms[awg][core_idx]["p"+str(ch_2_idx)+"_p"+str(ch_idx)+"fr"] = None
            else:
                pass

    npoints_pi_std = gate_npoints[standard_rf[0]]['rf'][standard_rf[1]]["pi"]
    npoints_pi_2_std = gate_npoints[standard_rf[0]]['rf'][standard_rf[1]]["pi_2"]
    if npoints_pi_std >= n_std[2]:
        n_pi_p_std = npoints_pi_std
    else:
        n_pi_p_std = n_std[2]

    if npoints_pi_2_std  >= n_std[2]:
        n_pi_2_p_std = npoints_pi_2_std
    else:
        n_pi_2_p_std = n_std[2]

    n_std_waveform_pi = len(rectangular_add_padding(npoints_pi_std, amp, min_points = npoints_pi_std, side_pad=added_padding))
    n_std_waveform_pi_2 = len(rectangular_add_padding(npoints_pi_2_std, amp, min_points = npoints_pi_2_std, side_pad=added_padding))

    n_std_waveform_pi_p_std = len(rectangular_add_padding(n_pi_p_std, amp, min_points = n_pi_p_std, side_pad=added_padding))
    n_std_waveform_pi_2_p_std = len(rectangular_add_padding(n_pi_2_p_std, amp, min_points = n_pi_2_p_std, side_pad=added_padding))


    if n_std_waveform_pi < 48:
         n_std_waveform_pi = 48
    else:
        pass
    if n_std_waveform_pi_2 < 48:
         n_std_waveform_pi_2 = 48
    else:
        pass
    if n_std_waveform_pi_p_std  < 48:
         n_std_waveform_pi_p_std  = 48
    else:
        pass
    if n_std_waveform_pi_2_p_std< 48:
         n_std_waveform_pi_2_p_std = 48
    else:
        pass

    for awg in channel_map:
        waveforms[awg] = {}
        for core_idx in channel_map[awg]:
            waveforms[awg][core_idx] = {}
            if channel_map[awg][core_idx]['rf'] == 1:
                gt_idx = channel_map[awg][core_idx]['gate_idx'][0]
                waveforms[awg][core_idx]["pi_pifr"] = rectangular_add_padding(gate_npoints[awg]["rf"][gt_idx]["pi"], amp, min_points = n_std_waveform_pi, side_pad=added_padding)
                waveforms[awg][core_idx]["pi_2_pi_2fr"] = rectangular_add_padding(gate_npoints[awg]["rf"][gt_idx]["pi_2"], amp, min_points = n_std_waveform_pi_2, side_pad=added_padding)
                waveforms[awg][core_idx]["pi_2_pifr"] = rectangular_add_padding(gate_npoints[awg]["rf"][gt_idx]["pi_2"], amp, min_points = n_std_waveform_pi, side_pad=added_padding)
                waveforms[awg][core_idx]["pi_p_stdfr"] = rectangular_add_padding(gate_npoints[awg]["rf"][gt_idx]["pi"], amp, min_points = n_std_waveform_pi_p_std, side_pad=added_padding)
                waveforms[awg][core_idx]["pi_2_p_stdfr"] = rectangular_add_padding(gate_npoints[awg]["rf"][gt_idx]["pi_2"], amp, min_points = n_std_waveform_pi_2_p_std, side_pad=added_padding)


            elif channel_map[awg][core_idx]['rf'] == 0:
                ch_1_idx = channel_map[awg][core_idx]['gate_idx'][0]
                ch_2_idx = channel_map[awg][core_idx]['gate_idx'][1]

                if n_std_waveform_pi < gate_npoints[awg]["plunger"][ch_1_idx]["p"]:
                    n_p1_pi_fr = gate_npoints[awg]["plunger"][ch_1_idx]["p"]
                else:
                    n_p1_pi_fr =  n_std_waveform_pi
                if n_std_waveform_pi < gate_npoints[awg]["plunger"][ch_2_idx]["p"]:
                    n_p2_pi_fr = gate_npoints[awg]["plunger"][ch_2_idx]["p"]
                else:
                    n_p2_pi_fr =  n_std_waveform_pi
                if n_std_waveform_pi_2 < gate_npoints[awg]["plunger"][ch_1_idx]["p"]:
                    n_p1_pi_2_fr = gate_npoints[awg]["plunger"][ch_1_idx]["p"]
                else:
                    n_p1_pi_2_fr =  n_std_waveform_pi_2
                if n_std_waveform_pi_2 < gate_npoints[awg]["plunger"][ch_2_idx]["p"]:
                    n_p2_pi_2_fr = gate_npoints[awg]["plunger"][ch_2_idx]["p"]
                else:
                    n_p2_pi_2_fr =  n_std_waveform_pi_2

                waveforms[awg][core_idx]["p"+str(ch_1_idx)+"_pifr"] = rectangular_add_padding(gate_npoints[awg]["plunger"][ch_1_idx]["p"], amp, min_points = n_p1_pi_fr, side_pad=added_padding)
                waveforms[awg][core_idx]["p"+str(ch_2_idx)+"_pifr"] = rectangular_add_padding(gate_npoints[awg]["plunger"][ch_2_idx]["p"], amp, min_points = n_p2_pi_fr, side_pad=added_padding)
                waveforms[awg][core_idx]["p"+str(ch_1_idx)+"_pi_2fr"] = rectangular_add_padding(gate_npoints[awg]["plunger"][ch_1_idx]["p"], amp, min_points = n_p1_pi_2_fr, side_pad=added_padding)
                waveforms[awg][core_idx]["p"+str(ch_2_idx)+"_pi_2fr"] = rectangular_add_padding(gate_npoints[awg]["plunger"][ch_2_idx]["p"], amp, min_points =  n_p2_pi_2_fr, side_pad=added_padding)

                for ch_idx in plunger_channels:
                    if gate_npoints[awg]["plunger"][ch_idx]["p"] < gate_npoints[awg]["plunger"][ch_1_idx]["p"]:
                        frame_p1_points = gate_npoints[awg]["plunger"][ch_1_idx]["p"]
                    elif gate_npoints[awg]["plunger"][ch_idx]["p"] >= gate_npoints[awg]["plunger"][ch_1_idx]["p"]:
                        frame_p1_points = gate_npoints[awg]["plunger"][ch_idx]["p"]
                    else:
                        pass
                    if gate_npoints[awg]["plunger"][ch_idx]["p"] < gate_npoints[awg]["plunger"][ch_2_idx]["p"]:
                        frame_p2_points = gate_npoints[awg]["plunger"][ch_2_idx]["p"]
                    elif gate_npoints[awg]["plunger"][ch_idx]["p"] >= gate_npoints[awg]["plunger"][ch_2_idx]["p"]:
                        frame_p2_points = gate_npoints[awg]["plunger"][ch_idx]["p"]
                    else:
                        pass
                    if frame_p1_points < 48:
                        frame_p1_points = 48
                    elif frame_p2_points < 48:
                        frame_p2_points = 48
                    else:
                        pass
                    npoints_fr = max(frame_p1_points, frame_p2_points)
                    waveforms[awg][core_idx]["p"+str(ch_1_idx)+"_p"+str(ch_idx)+"fr"] = rectangular_add_padding(gate_npoints[awg]["plunger"][ch_1_idx]["p"], amp, min_points = frame_p1_points, side_pad=added_padding)
                    waveforms[awg][core_idx]["p"+str(ch_2_idx)+"_p"+str(ch_idx)+"fr"] = rectangular_add_padding(gate_npoints[awg]["plunger"][ch_2_idx]["p"], amp, min_points = frame_p2_points, side_pad=added_padding)
            else:
                pass
    return waveforms


def config_hdawg(awg, gate_parameters, channel_mapping, channels_on=True):
    '''
    Configures HDAWG module to run a quantum algorithm. In particular, this function does the following:
    - enables oscillator control \n
    - sets oscillator frequencies \n
    - sets output amplitudes for each channel \n
    - turns on output channels \n


    Parameters:
                    awg (silospin.drivers.zi_hdawg.HdawgDriver): instance of HDAWG.
                    gate_parameters (dict): dictionary of gate paramters for each qubit.

    Returns:
       None.
    '''
    daq = awg._daq
    dev = awg._connection_settings["hdawg_id"]
    daq.setInt(f"/{dev}/system/awg/oscillatorcontrol", 1)
    rf_gate_param = gate_parameters["rf"]
    p_gate_param = gate_parameters["p"]
    channel_idxs = {"1": [1,2], "2": [3,4], "3": [5,6], "4": [7,8]}
    channel_osc_idxs = {1: 1, 2: 5, 3: 9, 4: 13}

    for core in channel_mapping:
        if channel_mapping[core]['rf'] == 1:
            core_idx = channel_mapping[core]['core_idx']
            osc_idx = channel_osc_idxs[core]
            i_idx = channel_mapping[core]['channel_core_number'][0]
            q_idx = channel_mapping[core]['channel_core_number'][1]
            awg.set_osc_freq(osc_idx, rf_gate_param[core_idx]["mod_freq"])
            awg.set_sine(i_idx, osc_idx)
            awg.set_sine(q_idx, osc_idx)
            awg.set_out_amp(i_idx, 1, rf_gate_param[core_idx]["i_amp"])
            awg.set_out_amp(q_idx, 2, rf_gate_param[core_idx]["q_amp"])
        elif channel_mapping[core]['rf'] == 0:
            if len(p_gate_param) == 0:
                pass
            else:
                core_idx = channel_mapping[core]['core_idx']
                p1_idx = channel_mapping[core]['channel_number'][0]
                p2_idx = channel_mapping[core]['channel_number'][1]
                p1_core_idx = channel_mapping[core]['channel_core_number'][0]
                p2_core_idx = channel_mapping[core]['channel_core_number'][1]
                awg.set_out_amp(p1_core_idx, 1, p_gate_param[p1_idx]["p_amp"])
                awg.set_out_amp(p2_core_idx, 2, p_gate_param[p2_idx]["p_amp"])
        else:
           pass

def add_arbitrary_gate(gate_symbol, gate_description, waveform_function, waveform_parameters, rf_output, pickle_file_location='C:\\Users\\Sigillito Lab\\Desktop\\experimental_workspaces\\quantum_dot_workspace_bluefors1\\experiment_parameters\\bluefors1_arb_gates.pickle'):
    ##gate_symbol (str), symbol dedicated for this specific gate
    ##gate_description (str), description of the gate's inputs/outputs and general funcionality
    ## waveform_function (str), string of function being executed. Order of waveform parameters should agree with order in gate_symbol (waveform parameters always come last as a convention). Should also be configured to be able to run. Outputs a waveform. Should always have name 'make_arb_waveform'.
    ## waveform_parameters (lst): list parameters of specific waveforms
    ## amplitude parameter (str): amplitude parameter to be modulated by command table
    ##rf_output (int): if 1, configured for dual I/Q channel. if 0, configured for a single channel.
    ## pickle_file_location (int): location of pickle file in memory (assuming this file already exists)
    ##gate symbol ==> gate(duration, amplitude, phase, waveform_parameters)
    ##parameters for each gate symbol should be
    ## {"gate_symbol" : {"parameters": { 0: {"symbol":  , "units": }, 1: , ..., N: }}, "rf": , "waveform_funct": }
    ## if amplitude or phase == 1 ==> need to implement in command table execution [not part of waveform]

    ## Special Gates :
    ## 1 . amp*gt[tau, phase, padding], for gt in {'X', 'Y', 'XXX', 'YYY'} [RF]
    ## 2. amp*s[tau, phase, f] [DC]
    ## 3. amp*r[tau] [DC]
    ## 4. amp*g[tau , var, mean] [DC]
    ## 5. t[N], adds arbitrary delay ==> implement as a play zero.

    arb_gates_pickle_initial = unpickle_qubit_parameters(pickle_file_location)
    # try:
    #     if gate_symbol in arb_gates_pickle_initial.keys()
    #         raise TypeError("Waveform name already taken!!")
    # except TypeError:
    #      raise
    arb_gates_pickle_initial[gate_symbol] = {"parameters": {} , "rf": rf_output, "description":  gate_description, "waveform_function": waveform_function}
    ##standard format for gate input [RF]: amp*gatesymbol(tau, phase, waveform_param[0], ..., waveform_param[N-1])
    ##standard format for gate input [DC]: amp*gatesymbol(tau, waveform_param[0], ..., waveform_param[N-1])
    ## amp is in volts (set by the command table index)
    ## tau in ns
    ## phase in degrees.
    ## amp, tau, and phase come by default depending on this being an RF or DC pulse
    idx = 0
    for param in waveform_parameters:
        arb_gates_pickle_initial[gate_symbol]["parameters"][idx] = param
        idx += 1

    with open(pickle_file_location, 'wb') as handle:
        pickle.dump(arb_gates_pickle_initial, handle, protocol = pickle.HIGHEST_PROTOCOL)

def obtain_waveform_arbitrary_gate_waveform(gate_label, tau, amp, parameter_values, pickle_file_location='C:\\Users\\Sigillito Lab\\Desktop\\experimental_workspaces\\quantum_dot_workspace_bluefors1\\experiment_parameters\\bluefors1_arb_gates.pickle'):
    arbgate_dict = unpickle_qubit_parameters(pickle_file_location)
    arbitrary_gate_function = arbgate_dict[gate_label]['waveform_function']

    local_var = {}
    parameters = {}
    sample_rate = 2.4
    execute_program = arbitrary_gate_function + '\nwaveform = make_arb_waveform(' + str(tau) + ',' + str(amp)
    for idx in range(len(parameter_values)):
        parameters[parameter_values[idx][0]] = parameter_values[idx][1]
        execute_program += ','+str(parameter_values[idx][1])
    execute_program += ')'
    parameters['sample_rate'] = sample_rate
    exec(execute_program, parameters, local_var)
    return local_var['waveform']

def evaluate_arb_waveform(gate_str, pickle_file_location='C:\\Users\\Sigillito Lab\\Desktop\\experimental_workspaces\\quantum_dot_workspace_bluefors1\\experiment_parameters\\bluefors1_arb_gates.pickle'):
     arb_gate_dict = unpickle_qubit_parameters(pickle_file_location)
     gt_label_idx = gate_str.find('*') + 1
     gt_label = gate_str[gt_label_idx]
     gt_parameters = arb_gate_dict[gt_label]['parameters']
     amp = float(gate_str[0:gate_str.find('*')])

     comma_idxs = [i for i, letter in enumerate(gate_str) if letter == '&']
     param_values = []
     tau_val = float(gate_str[gt_label_idx+2:comma_idxs[0]])
     if len(gt_parameters) == 0:
         pass
     elif len(gt_parameters) == 1:
         param_values.append((gt_parameters[0], float(gate_str[comma_idxs[0]+1:gt_label.find(']')])))
     else:
         for idx in range(len(param_values)-1):
             param_values.append((gt_parameters[idx], float(gate_str[comma_idxs[idx]+1:comma_idxs[idx+1]])))
         param_values.append(gt_parameters[len(param_values)], float(gate_str[comma_idxs[idx]+1:gt_label.find(']')]))

     waveform = obtain_waveform_arbitrary_gate_waveform(gt_label, tau_val, amp, param_values, pickle_file_location)
     return np.array(waveform)
